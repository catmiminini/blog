# 正则表达式

正则是匹配模式，要么匹配字符，要么匹配位置。

- 横向匹配：一个位置对应字符的数量不定。
- 纵向匹配：一个位置对应字符的种类不定。
- 匹配字符: 字符的位置
- 匹配位置: 字符间的位置

## 横向匹配

- 量词: `{m, n}` 至少 m 次, 至多 n 次
- 简写:
  - `{m, }` 至少 m 次
  - `{m}` = {m, m}
  - `?` = {0, 1}
  - `+` = {1, }
  - `*` = {0, }
- 贪婪匹配和惰性匹配
  惰性匹配在**量词后面**再加一个问号.
  - 贪婪匹配:`"1234 12345 123456".match(/\d{2,5}/g) //["1234", "12345", "12345"]`
  - 惰性匹配:`"1234 12345 123456".match(/\d{2,5}?/g) //["12", "12", "34", "12", "34", "12", "34", "56"]`

## 纵向匹配

- 字符组：`[abc]` a,b,c 三者之一。
- 范围：`[1-9a-z]`
- 排除字符组：`[^abc]`
- 简写：小写是字符组，大写是排除字符组

  - `\d`数字`[0-9]`
  - `\w` 单词字符`[0-9A-Za-z_]` 包含数字大小写字母下滑线
  - `\s` 空白符
  - `.` 任意字符

- 多选分支: (a|b)

## 匹配位置

字符串中的位置: "hello"中可分为 `#h#e#l#l#0#`, 其中#代表位置.

- `^` : 在多行匹配中匹配行开头
- `$` : 在多行匹配中匹配行结尾
- `\b` : 单词边界, 也就是\w 和\W 之间的位置, 包括\w 与^之间的位置, 和\w 与\$之间的位置
- `\B` : 非单词边界, 在字符串中所有位置中,除去\b,都是\B
- `(?=p)` : p 是一个子模式, 含义是说该位置后面的字符要匹配 p 模式
- `(?!p)` : (?=p) 的反面, 该位置后的字符不匹配 p 模式

正则表达式匹配位置的方式理解: 由于位置之间没有字符区别, 所以匹配位置的正则实际上是对全部位置进行遍历,并通过断言的方式筛选位置.

示例:

```js
// 数字千分位加逗号: 不改变字符, 改变位置
// 1. 数字开头位置不加逗号: (?!^)
// 2. 从后往前每3个数字加一个逗号: (?=(\d{3})+$)
// 3. 添加多个逗号: /g
var reg = /(?!^)(?=(\d{3})+$)/g
var result = '123456789'.replace(reg, ',')
// result = '123,456,789'
```

其中`'123456789'`共有 10 个位置, reg 可分为两部分`(?!^)`和`(?=(\d{3})+$)`.
其中`(?!^)`断言不选择开头位置, 还剩余 9 个可选位置;
`(?=(\d{3})+$)`含有子模式`(\d{3})+$`, 子模式匹配结束位置前有 3,6,9...个数字的位置, 在上面的 9 个位置中,只能选出 2 个有效位置;
最后通过`replace`方法将这 2 个位置替换为','.

## 匹配原理

- 没有回溯的匹配
- 有回溯的匹配

## 修饰符

- /g : global: 匹配所有字串。
- /m : multiple lines: 多行匹配
- /i : ignore case: 忽略大小写

## string 的正则方法

- string.match(reg) : return ['a', 'b'], 返回匹配的字串数组

## 参考

- [老姚的正则表达式小书](https://github.com/qdlaoyao/js-regex-mini-book)
